// Author: Robert Davis

#include "gmml/internal/coordinate_file.h"

#include <algorithm>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <stdexcept>
#include <vector>

#include "gmml/internal/environment.h"
#include "gmml/internal/geometry.h"
#include "utilities.h"

using std::string;
using std::vector;

namespace gmml {

const char *CoordinateFile::kDefaultTitle =
        "GENERATED BY GMML (http://code.google.com/p/gmml)";

struct CoordinateFile::Impl {
    Impl() : title_(kDefaultTitle), noncoordinate_count_(0) {}

    ~Impl() {
        cleanup();
    }

    void cleanup() {
        std::for_each(coordinates_.begin(), coordinates_.end(), DeletePtr());
    }

    void read(std::istream& in);
    bool process_coordinate_line(const string& line);
    Coordinate *parse_coordinate(const string& str);

    void bad_file(const std::string& error) {
        cleanup();
        throw std::invalid_argument(error);
    }

    void write_coordinate_range(std::ostream& out, int start, int end) const;
    void write_coordinate(std::ostream& out,
                          const Coordinate& coordinate) const;
    void write_component(std::ostream& out, double component) const;

    string title_;
    vector<Coordinate*> coordinates_;
    int noncoordinate_count_;
};

CoordinateFile::CoordinateFile() : impl_(new Impl) {
}

CoordinateFile::CoordinateFile(const string& file_name) : impl_(new Impl) {
    Readable::read(file_name);
}

CoordinateFile::~CoordinateFile() {
}

void CoordinateFile::read(std::istream& in) {
    impl_->read(in);
}

void CoordinateFile::write(std::ostream& out) const {
    out << impl_->title_ << std::endl;
    int coordinates = coordinate_count();
    out << std::setw(kCountLabelWidth) << coordinates << std::endl;
    impl_->write_coordinate_range(out, 0, coordinates - 1);
    impl_->write_coordinate_range(out, coordinates, size() - 1);
}

size_t CoordinateFile::size() const {
    return impl_->coordinates_.size();
}

int CoordinateFile::noncoordinate_count() const {
    return impl_->noncoordinate_count_;
}

const Coordinate& CoordinateFile::operator[](int index) const {
    if (0 <= index && index < size())
        return *impl_->coordinates_[index];
    string error = make_string() << "Invalid coordinate index: " <<
                                    index << ".";
    throw std::range_error(error);
}

void CoordinateFile::add_coordinate(const Coordinate& coordinate) {
    impl_->coordinates_.push_back(new Coordinate(coordinate));
}

void CoordinateFile::add_noncoordinate(double x, double y, double z) {
    impl_->coordinates_.push_back(new Coordinate(x, y, z));
    impl_->noncoordinate_count_++;
}


void CoordinateFile::Impl::read(std::istream& in) {
    string line;

    if (!getline(in, line)) {
        bad_file("Invalid coordinate file.");
    }
    trim(line);
    title_ = line;

    if (!getline(in, line)) {
        bad_file("Invalid coordinate file.");
    }
    int count_label = convert_string<int>(line);

    int line_index = 2;
    while (line_index++, getline(in, line)) {
        if (!process_coordinate_line(line)) {
            bad_file(make_string() << "Error on line " << line_index << ".");
        }
    }

    noncoordinate_count_ = coordinates_.size() - count_label;
}

bool CoordinateFile::Impl::process_coordinate_line(const string& line) {
    int coords_on_line = line.size()/kCoordinateWidth/3;
    for (int i = 0; i < coords_on_line; i++) {
        string crd = line.substr(i*kCoordinateWidth*3, kCoordinateWidth*3);
        try {
            Coordinate *coordinate = parse_coordinate(crd);
            coordinates_.push_back(coordinate);
        } catch (const ConversionException& e) {
            return false;
        }
    }
    return true;
}

Coordinate *CoordinateFile::Impl::parse_coordinate(const string& str) {
    double x = convert_string<double>(str.substr(0, kCoordinateWidth));
    double y = convert_string<double>(str.substr(kCoordinateWidth,
                                                 kCoordinateWidth));
    double z = convert_string<double>(str.substr(2*kCoordinateWidth,
                                                 kCoordinateWidth));
    return new Coordinate(x, y, z);
}

void CoordinateFile::Impl::write_coordinate_range(std::ostream& out,
                                                  int start, int end) const {
    int count = end - start + 1;
    bool is_odd = count & 1;
    for (int i = start; i < end - is_odd + 1; i += 2) {
        write_coordinate(out, *coordinates_[i]);
        write_coordinate(out, *coordinates_[i + 1]);
        out << std::endl;
    }
    if (is_odd) {
        write_coordinate(out, *coordinates_[end]);
        out << std::endl;
    }
}


void CoordinateFile::Impl::write_coordinate(
        std::ostream& out, const Coordinate& coordinate) const {
    write_component(out, coordinate.x);
    write_component(out, coordinate.y);
    write_component(out, coordinate.z);
}

void CoordinateFile::Impl::write_component(std::ostream& out,
                                           double component) const {
    out << std::setw(kCoordinateWidth) <<
           std::setprecision(kCoordinatePrecision) <<
           std::fixed <<
           component;
}

}  // namespace gmml
